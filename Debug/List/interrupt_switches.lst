###############################################################################
#
# IAR C/C++ Compiler V7.20.1.997/W32 for MSP430           29/May/2021  20:59:51
# Copyright 1996-2020 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.20
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\nopassword\Desktop\ECE_306\Project 06\interrupt_switches.c
#    Command line  =  
#        -f C:\Users\NOPASS~1\AppData\Local\Temp\EW8956.tmp
#        ("C:\Users\nopassword\Desktop\ECE_306\Project 06\interrupt_switches.c"
#        -lC "C:\Users\nopassword\Desktop\ECE_306\Project 06\Debug\List" -o
#        "C:\Users\nopassword\Desktop\ECE_306\Project 06\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430FR2355__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\430\lib\dlib\dl430xlsfn.h" -I
#        ./ --core=430X --data_model=small -On --multiplier=32
#        --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        C:\Users\nopassword\Desktop\ECE_306\Project
#        06\Debug\List\interrupt_switches.lst
#    Object file   =  
#        C:\Users\nopassword\Desktop\ECE_306\Project
#        06\Debug\Obj\interrupt_switches.r43
#
###############################################################################

C:\Users\nopassword\Desktop\ECE_306\Project 06\interrupt_switches.c
      1          // New code: from "hints from project 3a
      2          
      3          //------------------------------------------------------------------------------
      4          //
      5          //  Description: This file contains functions definitions for hardware switches on MSP430
      6          //
      7          //
      8          //  Mark Rubianes
      9          //  Jan 2021
     10          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
     11          //------------------------------------------------------------------------------
     12          
     13          //------------------------------------------------------------------------------
     14                //NOT ADDED TO PROJECT YET. ADD TO PROJECT, THEN DELETE .R43 FILE!!!
     15          #include  "functions.h"
     16          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x21a
   \   union <unnamed> _A_PAIE_L
   \                     _A_PAIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21c
   \   union <unnamed> _A_PAIFG_L
   \                     _A_PAIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23c
   \   union <unnamed> _A_PBIFG_L
   \                     _A_PBIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x384
   \   union <unnamed> _A_TB0CCTL1_L
   \                     _A_TB0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x386
   \   union <unnamed> _A_TB0CCTL2_L
   \                     _A_TB0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x394
   \   union <unnamed> _A_TB0CCR1_L
   \                     _A_TB0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2
     17          #include <string.h>
     18          #include "macros.h"
     19          
     20          //extern volatile unsigned char display_changed;
     21          //extern volatile unsigned char SW1_debug_counter = 0;
     22          //volatile int speed;

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23          volatile char SW2_Pressed;
   \                     SW2_Pressed:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     24          volatile char SW1_Pressed;
   \                     SW1_Pressed:
   \   000000                DS8 1
     25          
     26          /*
     27          count_debounce_SW1 and count_debounce_SW2 where defined as chars,
     28          error: Warning[Pa084]: pointless integer comparison, the result is always true
     29          
     30          I was comparing a char (1 byte) against an int (2 bytes)
     31          
     32          Debouncing code: debouncing is managing the hundreds of extra contacts that
     33          are made when a mechanical switch is pressed because the clock is running at
     34          the speed of thousands of times a second (Mhz range). This code is the software
     35          way of handling this problem, although it uses up clock cycles. A better solution
     36          is through hardware debouncing and filtering the contacts so it's a smooth
     37          transition.
     38          
     39          */
     40          
     41          
     42          
     43          // Using interrupts
     44          
     45          /*Starting Template
     46          #
     47          pragma vector = {Vector}
     48          // do not forget the header
     49          __interrupt
     50          void my_isr (void)
     51          // do whatever must be done
     52          }
     53          
     54          Using  #pragma vector = {vector_name}
     55          Tells the compiler it’s an ISR. This is important  because
     56          the ISR has a different stack frame compared with subroutine. This means
     57          it 1) Saves all registers and Flag register is also saved, and 3)
     58          Different return needed (REIT vs. EXITD)
     59          
     60          
     61          Latency is six cycles starting with the acceptance of an interrupt request
     62          and lasting until the start of execution of the first instruction of the
     63          service routine: GIE (Global Interrupt Enable) bit is set/cleared here.
     64          
     65          RETI (Return from Interrupt) takes five cycles
     66          
     67          Due to the pipelined CPU architecture, the instruction following
     68          the enable interrupt instruction ( is always executed, even if
     69          an interrupt service request is pending when the interrupts are
     70          enabled
     71          •
     72          If the enable interrupt instruction ( is immediately followed
     73          by a disable interrupt instruction ( a pending interrupt
     74          might not be serviced Further instructions after DINT might
     75          execute incorrectly and result in unexpected CPU execution It is
     76          recommended to always insert at least one instruction between
     77          EINT and DINT Note that any alternative instruction use that sets
     78          and immediately clears the CPU status register GIE bit must be
     79          considered in the same fashion
     80          
     81          
     82          Configure MCU:
     83          Enable interrupts for system  ?????
     84          
     85          */
     86          
     87          /*
     88          init timer b0 is only global setup needed for timers
     89          lcd won't work if DIV from hmwk 5 is still in place
     90          */
     91          
     92          #pragma vector = PORT4_VECTOR

   \                                 In  segment ISR_CODE, align 2
     93          __interrupt void switchP4_interrupt(void){
   \                     switchP4_interrupt:
     94            // Switch 1
     95            if (P4IFG & SW1) {
   \   000000   E2B33D02     BIT.B   #0x2, &0x23d
   \   000004   0E28         JNC     ??switchP4_interrupt_0
     96              /*
     97              1. Disable Switch 1
     98              2. Clear Switch 1 Flag  (only clears current interrup, but pending one will be irrelevant by the time we're done debouncing anyway)
     99              3. Clear TimerB 0 Interrupt Flag for Capture Compare Register 1
    100              4. Add Interval to TB 0 R for TB 0 CCR 1 (implying that the using CCR1 is suggested to use for debouncing SW1, and CCR2 for SW2)
    101              5. Enable TimerB 0 1
    102              */
    103          
    104              // (IFregister) 1 bit that will get masked in and out
    105          
    106              //temporarily disable switch interrupts by masking out the interrupt enable bits
    107              P4IE &= ~SW1;  // 1) "Interrupt Enable" bit
   \   000006   E2C33B02     BIC.B   #0x2, &0x23b
    108              P4IFG &= ~SW1; // 2) IFG SW1 cleared
   \   00000A   E2C33D02     BIC.B   #0x2, &0x23d
    109          
    110              // actionable code goes here
    111              SW1_Pressed = TRUE;
   \   00000E   D243....     MOV.B   #0x1, &SW1_Pressed
    112              //GREEN_LED_TOGGLE();
    113              
    114              //IR_LED_TOGGLE();
    115          
    116              /* Code to validate SW debouncing is working correctly
    117              //    SW1_debug_counter++;
    118              //
    119              //    HEXtoBCD(SW1_debug_counter);
    120              //    adc_line(3,0);
    121              //    display_changed = 1;
    122              */
    123          
    124              TB0CCTL1 &= ~CCIFG; // 3) clear any possible pending interrupt flags/faults
   \   000012   92C38403     BIC.W   #0x1, &0x384
    125              TB0CCR1 += TB0_SEC_0_050; // 4) Note: needs to be for 1 second for safe debounce
   \   000016   B250A8619403 ADD.W   #0x61a8, &0x394
    126              // 4) Alternate way: TB0CCR1 = TB0R + CCR1_200_MSEC_INTERVAL;
    127          
    128              TB0CCTL1 |= CCIE; // CCR1 enable interrupt
   \   00001C   B2D010008403 BIS.W   #0x10, &0x384
    129          
    130            }
    131          }
   \                     ??switchP4_interrupt_0:
   \   000022   0013         RETI
   \   000024                REQUIRE _A_PBIFG_L
   \   000024                REQUIRE _A_PBIE_L
   \   000024                REQUIRE _A_TB0CCTL1_L
   \   000024                REQUIRE _A_TB0CCR1_L
    132          #pragma vector = PORT2_VECTOR

   \                                 In  segment ISR_CODE, align 2
    133          __interrupt void switchP2_interrupt(void){
   \                     switchP2_interrupt:
    134            // Switch 2
    135            if (P2IFG & SW2) {
   \   000000   F2B21D02     BIT.B   #0x8, &0x21d
   \   000004   0E28         JNC     ??switchP2_interrupt_0
    136              //P2OUT ^= IR_LED; // Toggle IR LED
    137          
    138              P2IE &= ~SW2;  // 1) "Interrupt Enable" bit
   \   000006   F2C21B02     BIC.B   #0x8, &0x21b
    139              P2IFG &= ~SW2; // 2) IFG SW1 cleared
   \   00000A   F2C21D02     BIC.B   #0x8, &0x21d
    140          
    141              SW2_Pressed = TRUE;
   \   00000E   D243....     MOV.B   #0x1, &SW2_Pressed
    142              //RED_LED_TOGGLE();
    143          
    144              TB0CCTL2 &= ~CCIFG; // 3) clear any possible pending interrupt flags
   \   000012   92C38603     BIC.W   #0x1, &0x386
    145              TB0CCR2 += TB0_SEC_0_050; // 4) Note: needs to be for 1 second for safe debounce
   \   000016   B250A8619603 ADD.W   #0x61a8, &0x396
    146              // 4) Alternate way: TB0CCR1 = TB0R + CCR0_200_MSEC_INTERVAL;
    147          
    148              TB0CCTL2 |= CCIE; //
   \   00001C   B2D010008603 BIS.W   #0x10, &0x386
    149          
    150          
    151            }
    152          }
   \                     ??switchP2_interrupt_0:
   \   000022   0013         RETI
   \   000024                REQUIRE _A_PAIFG_L
   \   000024                REQUIRE _A_PAIE_L
   \   000024                REQUIRE _A_TB0CCTL2_L
   \   000024                REQUIRE _A_TB0CCR2_L

   \                                 In  segment INTVEC, offset 0x2c, root
   \                     `??switchP4_interrupt::??INTVEC 44`:
   \   00002C   ....         DC16    switchP4_interrupt

   \                                 In  segment INTVEC, offset 0x30, root
   \                     `??switchP2_interrupt::??INTVEC 48`:
   \   000030   ....         DC16    switchP2_interrupt
    153          /////// OLD SWITCh PROCESS CODE ///////////////////////////////////////////////////////////////
    154          /*
    155          
    156          void Switches_Process(void) {
    157          //
    158          // This function calls the individual Switch Functions
    159          //
    160            Switch1_Process();
    161            Switch2_Process();
    162          }
    163          //
    164          
    165          void Switch1_Process(void){
    166          //
    167          // Switch 1 Configurations
    168          //
    169            if(okay_to_look_at_switch1 && sw1_position){
    170              if(!(SWITCH1_INPUT_STATE())){  // !(P4IN & SW1) means switch is LOW // & here is bitwise
    171                //AND (if T, switch is high, default state)
    172          
    173                // P4IN & SW1 is how you check the in state of switch 1, the P4IN
    174                //special purpose register is multiplexed with the pin SW1
    175                sw1_position = PRESSED;
    176                okay_to_look_at_switch1 = NOT_OKAY; // not okay until debounce count down
    177                count_debounce_SW1 = DEBOUNCE_RESTART; //reset here, switch hit for first time
    178                //my button press code
    179                motion_state_select();
    180          
    181                //fet_test_state_select();
    182          
    183                //all_motors_OFF();
    184                //reverse_ON();
    185          
    186              }
    187            }
    188          // this is a sepparate if statement
    189            if(count_debounce_SW1 < DEBOUNCE_TIME){
    190              //RED_LED_TOGGLE();  uncomment to visualize length of debounce period
    191              count_debounce_SW1++;
    192            }else{  //enough time has incremented to be safe to call switch released
    193              okay_to_look_at_switch1 = OKAY; //flags switch as okay to look at
    194              if(SWITCH1_INPUT_STATE()){
    195                sw1_position = RELEASED;
    196              }
    197           }
    198          }
    199            //
    200          
    201          void Switch2_Process(void){
    202            //
    203            // Switch 2 Configurations
    204            //
    205            if(okay_to_look_at_switch2 && sw2_position){
    206              if(!(SWITCH2_INPUT_STATE())){
    207                sw2_position = PRESSED;
    208                okay_to_look_at_switch2 = NOT_OKAY;
    209                count_debounce_SW2 = DEBOUNCE_RESTART;
    210          
    211                //my button press code not implemented yet
    212                GREEN_LED_OFF();
    213                RED_LED_TOGGLE();
    214                //stop();
    215                //shape_state_select();
    216          
    217                //fet_test_activate();
    218          
    219                //all_motors_OFF();
    220                //reverse_OFF();
    221              }
    222            }
    223            if(count_debounce_SW2 < DEBOUNCE_TIME){
    224              //GREEN_LED_TOGGLE();  uncomment to visualize length of debounce period
    225              count_debounce_SW2++;
    226            }else{
    227              okay_to_look_at_switch2 = OKAY;
    228              if(SWITCH2_INPUT_STATE()){
    229                sw2_position = RELEASED;
    230              }
    231            }
    232          }
    233          //
    234          
    235          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   switchP2_interrupt
      4   switchP4_interrupt


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  SW1_Pressed
       1  SW2_Pressed
       2  _A_PAIE_L
       2  _A_PAIFG_L
       2  _A_PBIE_L
       2  _A_PBIFG_L
       2  _A_TB0CCR1_L
       2  _A_TB0CCR2_L
       2  _A_TB0CCTL1_L
       2  _A_TB0CCTL2_L
      36  switchP2_interrupt
       2  switchP2_interrupt::??INTVEC 48
      36  switchP4_interrupt
       2  switchP4_interrupt::??INTVEC 44

 
 16 bytes in segment DATA16_AN
  2 bytes in segment DATA16_Z
  4 bytes in segment INTVEC
 72 bytes in segment ISR_CODE
 
 72 bytes of CODE  memory
  0 bytes of CONST memory (+  4 bytes shared)
  2 bytes of DATA  memory (+ 16 bytes shared)

Errors: none
Warnings: none
